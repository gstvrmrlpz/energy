%%
%% Copyright 2007-2024 Elsevier Ltd
%%
%% This file is part of the 'Elsarticle Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.3 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.3 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'Elsarticle Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for Elsevier's document class `elsarticle'
%% with numbered style bibliographic references
%% SP 2008/03/01
%% $Id: elsarticle-template-num.tex 249 2024-04-06 10:51:24Z rishi $
%%
\documentclass[preprint,12pt]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[authoryear,preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% For including figures, graphicx.sty has been loaded in
%% elsarticle.cls. If you prefer to use the old commands
%% please give \usepackage{epsfig}

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
%% The amsmath package provides various useful equation environments.
\usepackage{amsmath}
%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

%% The lineno packages adds line numbers. Start line numbering with
%% \begin{linenumbers}, end it with \end{linenumbers}. Or switch it on
%% for the whole article with \linenumbers.
%% \usepackage{lineno}

\usepackage{hyperref}

\journal{Swarm and Evolutionary Computation}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for theassociated footnote;
%% use the fnref command within \author or \affiliation for footnotes;
%% use the fntext command for theassociated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for theassociated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \affiliation{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%% \fntext[label3]{}

\title{Sorcerer's apprentices blindfolding compilers and their options}

%% use optional labels to link authors explicitly to addresses:
%% \author[label1,label2]{}
%% \affiliation[label1]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}
%%
%% \affiliation[label2]{organization={},
%%             addressline={},
%%             city={},
%%             postcode={},
%%             state={},
%%             country={}}

\author{Gustavo Romero-L칩pez, Juan J. Merelo-Guerv칩s} %% Author name

%% Author affiliation
\affiliation{organization={Department of Computer Engineering, Automatics and Robotics},%Department and Organization
            city={Granada},
            postcode={18071},
            country={Spain}}

%% Abstract
\begin{abstract}
%% Text of abstract
Abstract text.
\end{abstract}

%%Graphical abstract
\begin{graphicalabstract}
%\includegraphics{grabs}
\end{graphicalabstract}

%%Research highlights
\begin{highlights}
\item Research highlight 1
\item Research highlight 2
\end{highlights}

%% Keywords
\begin{keyword}
%% keywords here, in the form: keyword \sep keyword

%% PACS codes here, in the form: \PACS code \sep code

%% MSC codes here, in the form: \MSC code \sep code
%% or \MSC[2008] code \sep code (2000 is the default)

\end{keyword}

\end{frontmatter}

%% Add \usepackage{lineno} before \begin{document} and uncomment
%% following line to enable line numbers
%% \linenumbers

%% main text
%%

%% Use \section commands to start a section
\section{Introduction}
\label{intro}


In general trying to make scientific results involve profiling algorithms, followed by an energy profile that finds out the energy bottlenecks among the different functions \cite{7155416}. But once those bottlenecks are found, we are faced with a myriad of possibilities, even if we restrict, like we do in our paper, to a single programming language. Compiled languages like this one have different options that affect performance in a more or less predictable way, and energy consumption in a way that is not known in advance. Let's examine them:\begin{itemize}
\item The first level is the compiler choice one: Most compiled languages have different compilers, designed and produced by different open source or commercial organizations. In the case of C++, there are at least two major ones: clang++, from LLVM, and g++, from GNU. % Need to add citations here
That without even taking into account different language standards and different compiler versions.
\item The second level is the different options that you can use when generating the executable. \begin{itemize}
    \item Most compilers have options regarding the architecture and machine instruction set that should be targeted. Programs can be compiled for a generic architecture, e.g. {\tt -march=i686}, or include instructions set that are specific to a brand or generation, e.g. {\tt -mtune=znver5}.
    \item The optimization level is also a compiler flag, that usually targets performance. Checking which optimization level, or which combination of optimization high-level flags is the best for energy consumption is not a priori known, and needs to be measured. This is controversial flag as for many years, the maximun optimization level {\tt -O3}, has been considered buggy and not completly reliable, but not anymore.
    \item Some compiler use an intermediate representation, mainly with the object of allowing static analysis as well as cross-compilation, but this representation can have an impact optimization as well as energy consumption. % no es posible probarlas - tampoco los algoritmos, pero habr치 que poner todos los temas posibles.
    \item Finally, compilers allow user selection of the language standard that is being followed. This might affect, besides the language constructs that are allowed, how code is generated. % no afecta significativamente JJ - pues se pone en la exploraci칩n inicial
\end{itemize}
\item The next level is the algorithm level: there are always different ways to implement the code, which can have different complexity, but also different energy consumption depending on how CPU and memory are used and how the code for the specific implementation is generated. Although this can certainly be examined for a different problem or workload, in evolutionary algorithms the amount of improvements we can obtain is very limited.
\item At the language level we can use different data structures to implement the problem domain objects; in general, an algorithm is not going to specify the specific data structure that needs to be used; choosing one or the other will impact energy consumption if only for the different memory layout and occupation that every one has. The classic speed vs size trade off that may arise from every problem, e.g. using {\tt std::vector<bool>} vs {\tt std::vector<char>} to implement a vector of boolean values; there might be other trade offs involved related to the complexity of accessing data packed in structures through references to individual bits.
\end{itemize}

In this paper we will try to find a combination of parameters and engineering choices that minimize energy consumption in a generic evolutionary algorithm by systematically researching the amount of energy consumed by common EA operators, and an integer-based heavy-weight function, Hierarchical-If-And-Only-If (HIFF) problem. And we will do so by answering the following research questions:\begin{itemize}
\item RQ1 Are there combinations, parameter values or choices that can be discarded by baseline measures because they are either neutral from the point of view of energy spent or significantly slower than others?
\item RQ2 What kind of decisions have the biggest impact on energy consumption?
\item RQ3 Are rankings of energy consumption consistent across different architectures?
\item RQ4 How does the power consumption of C++ evolve as its versions and standards advance?
\end{itemize}

\section{Methodology}

There is no fixed methodology for measuring energy consumption across a number of different machines with possibly different operating systems and hardware architectures. In \cite{jay2023experimental} Jay el al. delves into energy consumption, its measurement and the software tools needed to gather information about. The most widely used tool for its convenience is the Running Average Power Limit (RAPL) \cite{david2010rapl} interface through a wide range of tools like {\sf perf} \cite{de2010new}.

This is the approach followed in previous work \cite{zig1,zig2}, although by using the {\sf pinpoint} \cite{9307947} software as a {\sf perf} alternative we can also measure energy in MacOS. Since in this paper we are focused on specific languages, in principle independently of the operating system, {\sf perf} can perfectly cover what we are looking for. Using this tool, our methodology will follow the steps shown below:
\begin{itemize}
\item Decide which functions were the target for profiling, since energy profilers are unable to measure energy consumption at the function, or function call, level, thus needing to create executables where single functions are executed.
\item From those energy profiles, a baseline needs to be established. This baseline should include any energy expenses of the system, and, if possible, energy spent in data initialization and preparation. This baseline measurements can include discarding parametrizations or options that are either statistically indistinguishable from others or simply spending too much energy to be considered.
\item Finally, an experimental setup where different, relevant configurations and parametrizations are cross-tested so that those with the lowest energy performance can be selected and explained.
\end{itemize}


<<energy.setup, echo=F,message=F,warning=F>>=
library(dplyr)
library(ggplot2)
library(kableExtra)

pccito.raw <- read.csv("../data/pccito-20240715-213921.csv",sep=";")
pccito.init <- pccito.raw[pccito.raw$work=="i",]
pccito.init$seed <- NULL
pccito.init$work <- NULL

pccito.init %>% group_by(X.compiler,opt,program,length) %>% summarise(mean.energy=mean(energy),sd.energy=sd(energy),mean.time = mean(time), sd.time = sd(time)) -> pccito.summary

pccito.summary[ pccito.summary$opt=="-O2",] %>% arrange(length,opt,X.compiler,program) %>% kable(caption="Energy consumption by compiler and data structure, optimization level = O2") %>% kable_styling(bootstrap_options = c("striped"))
@

<<energy.setup.2, echo=F,message=F,warning=F>>=
pccito.summary[ pccito.summary$opt=="-O3",] %>% arrange(length,opt,X.compiler,program) %>% kable(caption="Energy consumption by compiler and data structure, optimization level = O3") %>% kable_styling(bootstrap_options = c("striped"))

pccito.init$length <- as.factor(pccito.init$length)
# ggplot(pccito.init[ pccito.init$program == "bitset",],aes(x=length,y=energy,color=X.compiler, shape=opt)) + geom_point(alpha=0.4) + geom_jitter(width=0.2) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Energy consumption by compiler and optimization level",x="time",y="Energy consumption (Joules)") + scale_fill_brewer(palette="Set1")

pccito.energy.lm <- lm(energy ~  program + opt + X.compiler + length, data=pccito.init)

amd.raw <- read.csv("../data/amd-20240715-170708.csv",sep=";")
amd.init <- amd.raw[amd.raw$work=="i",]
amd.init$seed <- NULL
amd.init$work <- NULL

amd.init %>% group_by(X.compiler,opt,program,length) %>% summarise(mean.energy=mean(energy),sd.energy=sd(energy),mean.time = mean(time), sd.time = sd(time)) -> amd.summary

# ggplot(amd.init,aes(x=time,y=energy,shape=X.compiler,color=program)) + geom_point(alpha=0.4) + theme_minimal() + theme(axis.text.x = element_text(angle = 90, hjust = 1)) + labs(title="Energy consumption by compiler and optimization level",x="time",y="Energy consumption (Joules)") + scale_fill_brewer(palette="Set1")

amd.energy.lm <- lm(energy ~  program + opt + X.compiler + length, data=amd.init) # saved for later

@

As we have done in other papers, we will use the initialization of the set of chromosomes with different parametrizations to establish the baseline, but at the same time to eliminate, from the start, any configuration that we can confidently establish as not sufficiently energy-efficient. In order to do that we have run a set of 15 tests with every parametrization using two compilers (g++ and clang++), two possible optimization levels of the compiler (-O2 and -O3), as well as the usual three chromosome lengths: 512, 1024 and 2048. We have also tested 4 different data structures to represent the chromosome:\begin{itemize}
\item \texttt{bitset} a uses the C++ dynamic bitset data structure. % maybe add more about this one.
\item \texttt{bvector} uses the C++ vector data structure from the standard template library, instantiated with the \texttt{bool} type.
\item \texttt{cvector} uses the C++ vector data structure from the standard template library, instantiated with characters.
\item \texttt{string} uses C++ strings, with chars '1' and '0' representing the integer values {\tt 1} and {\tt 0}.
\end{itemize}

The main difference between the first two data structures and the second ones is the fact that the former are {\em packed}, that is, in order to save memory, bits are packed to a byte; the latter are not. This will imply a certain effort to "unpack" them in order to use them, which might have an impact in the energy consumption. This is effectively what we can observe in Table \ref{tab:energy.setup}, and \ref{tab:energy.setup.2}, where we group these types of data structures (run as different programs) in a single column, and we can observe than, in general, for every compiler and optimization level, "packed" structures consume more energy than non-packed ones. There are some exceptions: when -O2 is used, g++ consumes less energy for packed structures for every length of the chromosome. We can apply a linear model for prediction of consumption depending on the rest of the factors.

\section{Results}
\label{sec:res}

\section{Conclusions}
\label{sec:con}


\bibliographystyle{elsarticle-num}
\bibliography{cplusplus-energy,energy,ours}

%% else use the following coding to input the bibitems directly in the
%% TeX file.

%% Refer following link for more details about bibliography and citations.
%% https://en.wikibooks.org/wiki/LaTeX/Bibliography_Management


\end{document}

\endinput
%%
%% End of file `elsarticle-template-num.tex'.
