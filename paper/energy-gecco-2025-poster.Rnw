\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{gensymb}

% \acmDOI{10.1145/nnnnnnn.nnnnnnn} % To be updated after completing copyright process
% \acmISBN{978-x-xxxx-xxxx-x/YY/MM} % To be updated after completing copyright process
% \acmConference[GECCO '25]{The Genetic and Evolutionary Computation Conference 2025}{July 14--18, 2025}{MÃ¡laga, Spain}
% \acmYear{2025}
% \copyrightyear{2025}

\begin{document}
\title{Analyzing per-component energy consumption of evolutionary algorithms implemented in low-level languages}
\subtitle{Comparison of C++ and {\sf zig} in key evolutionary algorithm functions}
\renewcommand{\shorttitle}{TBD}

\author{Ben Trovato}
\authornote{Boilerplate author names have been kept for double-blind review.}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{trovato@corporation.com}

\author{G.K.M. Tobin}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{webmaster@marysville-ohio.com}

\author{Lars Th{\o}rv{\"a}ld}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{B. Trovato et al.}

\begin{abstract}

Trying to design software systems in such a way that they consume a minimal amount of energy is simply good engineering practice. Scientific software is no exception; in this case we will put our focus on evolutionary algorithms and the patterns of energy consumption in memory and CPU for two different, low-level, languages: The mainstream C++ and the emerging {\sf zig}. By setting up a methodology that gives us a precise measure of the energy spent by key evolutionary algorithm functions, we can give the scientific software engineer some actionable insights on how to write energy-conscious, and thus energy-thrifty, evolutionary algorithms. Our experiments show that, even having very low energy consumption in both cases, C++ can achieve a significant reduction in energy consumption for some integer-based fitness functions, as well as very good performance on classical genetic operators. Besides, the experimental results have a low variability, as compared to {\sf zig}, making it in the short and medium run the best of the two languages for evolutionary algorithms.

\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011074.10011075.10011079.10011080</concept_id>
       <concept_desc>Software and its engineering~Software design techniques</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797</concept_id>
       <concept_desc>Theory of computation~Optimization with randomized search heuristics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010061.10011795</concept_id>
       <concept_desc>Theory of computation~Random search heuristics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797.10011799</concept_id>
       <concept_desc>Theory of computation~Evolutionary algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010941.10010949.10010957.10010964</concept_id>
       <concept_desc>Software and its engineering~Power management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Software design techniques}
\ccsdesc[300]{Theory of computation~Optimization with randomized search heuristics}
\ccsdesc[500]{Theory of computation~Random search heuristics}
\ccsdesc[500]{Theory of computation~Evolutionary algorithms}
\ccsdesc[500]{Software and its engineering~Power management}

\keywords{Green computing, software engineering, evolutionary algorithms, genetic algorithms, energy-aware algorithms}


\maketitle

\section{Introduction}

Until a short time ago, efficiency in the implementation of an algorithms referred mostly, if not exclusively, to performance; software platforms are designed so that this can be achieved through relatively easily configuration settings, as well as using higher performance hardware. Focusing in lowering the energy footprint of said implementation, however, needs a different approach, starting with a methodology that allows to separate the footprint of our workload from that of the whole system and boilerplate operations performed before it. We also need to focus on specific functions as opposed to a whole implementation. In this paper, we will compare different implementations of the essential functions in evolutionary algorithms in two languages, C++ and {\sf zig}, in a specific hardware environment, trying to find an answer to these questions:\begin{itemize}
\item[RQ1] Is there a specific data structure that is more energy-efficient than others for the workload under study?
\item[RQ2] If any of the two languages spends less energy, is performance or power the cause?
\item[RQ3] Is there a specific combination of data structure and language that can be said to be more energy efficient and by which factor?
\end{itemize}


\section{Methodology}\label{sec:methodology}

In order to read the energy-consumption registers we have used a tool called {\sf pinpoint} \cite{pinpoint}, as we have done in other papers \cite{wivace23,lion24}. Every program is run 30 times for every parameter combination on a Linux machine {\tt 6.8.0-40-generic \#40~22.04.3-Ubuntu SMP} using an Intel Core i7-10610 CPU at 1.8GHz with 8 cores. We use {\sf zig}  version 0.13.0, which is the last stable one at the time of writing this paper. Unlike we did in other papers, we have switched to {\tt clang++} at version {\tt 14.0.0}; the main reason is that since {\sf zig} uses the same LLVM backend \cite{lattner2006introduction}, this leveled a bit the playing field, eliminating the unfair low-level optimization advantage the GNU C++ compiler could have. The {\sf pinpoint} was compiled from source and commit hash {\tt dfee658}.

In order to separate what our  functions of interest consume from the rest of the system, we need to establish a baseline measurement; here, as in \cite{wivace23} on, we have started to use a different approach from the paragraph above, using a baseline program that generates chromosomes using two data structures: a character ("0" or "1") array or a Boolean ({\sf True} or {\sf False}) array.

<<energy.gecco.generation, echo=FALSE, message=FALSE, fig.height=4, fig.cap="Energy vs. time for the chromosome generation problem (baseline). We use different shapes for data structures: circles for Boolean vectors, triangles for strings; languages are represented by different colors, with red representing C++ and blue zig; chromosome size is also represented by point size, with biggest corresponding to 2048, smallest to 512. Lines represent a linear regression over experimental data from the same data structure.">>=
library(knitr)
zig.gen.bool <- read.csv("../data/sea25-bool-base-11-Jan-11-54-03.csv")
zig.gen.bool$data.structure <- "bvector"
zig.gen.string <- read.csv("../data/sea25-string-base-11-Jan-11-55-50.csv")
zig.gen.string$data.structure <- "string"
cpp.gen.bool <- read.csv("../data/sea-bool-base-11-Jan-13-09-14.csv")
cpp.gen.bool$data.structure <- "bvector"
names(cpp.gen.bool)[names(cpp.gen.bool) == "Psys"] <- "PSys"
names(cpp.gen.bool)[names(cpp.gen.bool) == "Core"] <- "Cores"
cpp.gen.string <- read.csv("../data/sea-string-base-11-Jan-13-06-25.csv")
names(cpp.gen.string)[names(cpp.gen.string) == "Psys"] <- "PSys"
names(cpp.gen.string)[names(cpp.gen.string) == "Core"] <- "Cores"
cpp.gen.string$data.structure <- "string"

gen.data <- rbind(zig.gen.bool, zig.gen.string, cpp.gen.bool, cpp.gen.string)
gen.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
gen.data$point.size <- log2(gen.data$size)-7

library(dplyr)
gen.data %>% group_by(language, data.structure, size ) %>% summarise(mean(PSys), sd(PSys), mean(seconds), sd(seconds)) -> gen.data.summary

library(ggplot2)
ggplot(gen.data, aes(x=seconds, y=PSys, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + geom_smooth(method="lm", aes( group=interaction(language,data.structure))) + labs(x="Time (s)", y="Energy (J)") + theme(legend.position="none")
@

What we have represented in Figure~\ref{fig:energy.gecco.generation} is an energy consumption ($y$ axis) vs time ($x$ axis) plot for every experiment and data structure, with a linear regression  that would represent the power consumed (being power equal to energy divided by time). C++ (red) seems better for the smallest size (512 bits), but it is definitely worse for the largest size, so for the time being no data structure will be discarded.

<<energy.gecco.generation.boxplot, echo=FALSE, message=FALSE, fig.height=4, fig.cap="Energy boxplot for the chromosome generation problem (baseline).">>=
gen.data$size <- as.factor(gen.data$size)
ggplot(gen.data, aes(x=size, y=PSys, fill=language,linetype=data.structure)) + geom_boxplot() + theme_minimal() + labs(x="Data structure", y="Energy (J)")
@

Figure~\ref{fig:energy.gecco.generation.boxplot} synthesizes in a single chart the energy consumption for the chromosome generation problem for both languages and data structures. It grows much faster for C++ than for {\sf zig}. While it is slightly better for the smallest size, energy consumption for strings is virtually the same for the middle size, but it takes off for the largest size. However, it is curious to observe that a specific data structure does not guarantee better energy consumption: Boolean vectors consume more energy in C++, while they consume {\em less} in {\sf zig}.

<<energy.gecco.histo, echo=F, message=F, fig.height=4, fig.cap="Histogram of energy consumption for the generation of Boolean vectors in C++ of length 2048",  fig.align="center">>=
ggplot(cpp.gen.bool[ cpp.gen.bool$size == 1024,], aes(x=PSys)) + geom_histogram(binwidth = 2) + theme_minimal() + labs(x="Energy (J)", y="Frequency")
@

It is interesting to note in this Figure~\ref{fig:energy.gecco.generation}, however, the dispersion of the data points along the $y$ axis (Energy). While other factors in the hardware and operating system may cause some spread over the $x$ axis (time), the variation is actually relatively small; however, energy spent even for running times that are very similar might experience variations on the order of 10 or more joules (for this specific problem), which is around 20\% of the total energy measured. In Figure \ref{fig:energy.gecco.histo} we plot the histogram of energy consumption for the option with the most extensive range, Boolean vectors in C++ of length 1024 (the one that presents the largest variation). Besides seeing a skewed distribution, the range of variation goes from around 60 to almost 90 for the 30 experiments. This, on one hand, indicates the presence of a system overhead that is difficult to eliminate, but is also a symptom of the complicated relationship between hardware and software managed by the different energy handling mechanisms in the operating system, firmware, and CPU microcode. This makes energy consumption relatively unpredictable (within a certain range of variation), but it indicates that any methodology for profiling energy consumption should, in many cases, take into account also this variability, beyond simply using averages or central measures. In this set of experiments, we have increased the number to 30 (as opposed to 15), trying to follow a more rigorous statistical approach.

We need, however, to measure the consumption of actual genetic operators. We will do this in the next section.

\section{Results}\label{sec:results}

<<energy.gecco.ops, echo=FALSE, message=FALSE, fig.height=4, fig.cap="Delta energy from baseline vs. delta time from baseline for genetic operators problem. Shapes and colors as in the previous Figure.">>=
zig.ops.bool <- read.csv("../data/sea25-bool-ops-11-Jan-12-02-19.csv")
zig.ops.bool$data.structure <- "bvector"
zig.ops.bool$delta.PSys <- zig.ops.bool$PSys - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
zig.ops.bool$delta.seconds <- zig.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.ops.string <- read.csv("../data/sea25-string-ops-11-Jan-12-00-03.csv")
zig.ops.string$data.structure <- "string"
zig.ops.string$delta.PSys <- zig.ops.string$PSys - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
zig.ops.string$delta.seconds <- zig.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.bool <- read.csv("../data/sea-bool-ops-11-Jan-13-16-29.csv")
cpp.ops.bool$data.structure <- "bvector"
names(cpp.ops.bool)[names(cpp.ops.bool) == "Psys"] <- "PSys"
names(cpp.ops.bool)[names(cpp.ops.bool) == "Core"] <- "Cores"
cpp.ops.bool$delta.PSys <- cpp.ops.bool$PSys - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
cpp.ops.bool$delta.seconds <- cpp.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.string <- read.csv("../data/sea-string-ops-11-Jan-13-24-20.csv")
cpp.ops.string$data.structure <- "string"
names(cpp.ops.string)[names(cpp.ops.string) == "Psys"] <- "PSys"
names(cpp.ops.string)[names(cpp.ops.string) == "Core"] <- "Cores"
cpp.ops.string$delta.PSys <- cpp.ops.string$PSys - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
cpp.ops.string$delta.seconds <- cpp.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))

ops.data <- rbind(zig.ops.bool, zig.ops.string, cpp.ops.bool, cpp.ops.string)
ops.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
ops.data$point.size <- log2(ops.data$size)-7

ops.data %>% group_by(language, data.structure, size) %>% summarise(mean(delta.PSys), sd(delta.PSys), mean(delta.seconds), sd(delta.seconds)) -> ops.data.summary

ggplot(ops.data, aes(x=delta.seconds, y=delta.PSys, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + labs(x="Time (s)", y="Energy (J)") + theme(legend.position="none")
@

We have performed a series of experiments using a triad of genetic operators: crossover, mutation and count-ones.
The results of applying these operators to the chromosome have been shown in Figure~\ref{fig:energy.gecco.ops}, where the average energy consumption and time for every size, language, and data structure in the baseline generation operation above have been subtracted from the numeric value obtained. However, we observe  that applying the genetic operators {\em after} its generation results in less-than-0 energy consumption and, in some cases, negative time. This is due to the lack of precision in measurements; for different registers precision varies between 2\% and 5\%. What we are seeing, in this case, is probably a combination of those operations taking less than 5\% of the total time required by generation + system overhead in some cases, added to some probably optimizations carried out by the compiler that merge generation + operation into a single machine code op, which consumes less than originally.

There is a clear separation between circles (corresponding to Boolean vectors) and triangles (corresponding to strings); the former {\em do} have some energy consumption and can then be discarded as more energy-consuming at least in the worst case and in the context of this experiment. This would answer research question 1: strings consume less energy than Boolean vectors, and this holds across the two low-level languages measured.

On the other hand, we do observe that the (negative) energy consumption is larger for C++ than for Zig, so even if it means combining two operations (generation and genetic operators) that are usually performed in disparate number of calls, we will compare the actual wallclock time.

<<energy.gecco.string, echo=F, message=F, fig.height=4, fig.cap="Boxplot of PSys energy consumption using the bit string chromosome for the two languages and different sizes",  fig.align="center">>=
ops.data$size <- as.factor(ops.data$size)
ggplot(ops.data[ops.data$data.structure=="string",], aes(x=size, y=PSys, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Chromosome size", y="Energy (J)")
string.ops.data <- ops.data[ops.data$data.structure=="string",]
differences.512 <- t.test(string.ops.data[string.ops.data$size==512 & string.ops.data$language=="c++",]$PSys, string.ops.data[string.ops.data$size==512 & string.ops.data$language=="zig",]$PSys,alternative = "less")
differences.1024 <- t.test(string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="c++",]$PSys, string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="zig",]$PSys,alternative = "less")
differences.2048 <- t.test(string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="c++",]$PSys, string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="zig",]$PSys, alternative = "greater")
@

We have plotted the total energy consumed for the program that generates 40K bitstrings and then performs genetic operators on them in Figure \ref{fig:energy.gecco.string}; side by side, energy spent by C++ (left of tick) and {\sf zig} (right) are shown. The picture is more nuanced than what we observed in Figure \ref{fig:energy.gecco.generation.boxplot}: C++ beats {\sf zig} for the lesser sizes and is beaten by {\sf zig} by a small margin for the larger size. Side-by-side differences are significant, so in this case there is a real difference between the two languages, although it is not always in the same direction. Variability, in this case, plays against C++, since, except for 512 bits, the worst-case result is always worse than the worst-case for {\sf zig}, even for 1024 bits, where the average is much better.

<<energy.gecco.string.power, echo=F, message=F, fig.height=4, fig.cap="Boxplot of PSys power (energy over time) consumption using the bit string chromosome for the two languages and different sizes.",  fig.align="center">>=
string.ops.data$power <- string.ops.data$PSys/string.ops.data$seconds
ggplot(string.ops.data, aes(x=size, y=power, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Chromosome size", y="Power (w)")
@

In order to ascertain what is the key to low energy consumption in the case of C++ (and answer RQ2), we also plot the power consumption in Figure \ref{fig:energy.gecco.string.power}, obtained by dividing energy by time. The result shows that while C++ draws an amount of power that increases in a relatively slow way from the system-on-chip, the amount used by {\sf zig} remains almost constant, albeit increasing; the problem is that this constant amount of power is always higher than for C++ for the same bit string size.

Answering RQ2, this means that C++ consumes less energy not because it is faster (which in some cases might be the case, but because the machine-code instructions its compiler generates are less power-hungry than for the case of {\sf zig}. This is an interesting result, which is probably related to the different way C++ and {\sf zig} handle memory allocation, with {\sf zig} always using explicit memory allocation; this might be a stabilizing and safety factor, but certainly consumes more power. Since the low-level optimizations will be the same in both cases, since they both use the LLVM backend, that factor, along with other higher-level optimizations performed by the language compilers themselves might be the factors that cause this difference. This might be the case for more general workloads, but it needs to be confirmed, due to the small number of these studies that have been published so far.

<<energy.gecco.hiff, echo=FALSE, message=FALSE, fig.height=4, fig.cap="Delta energy from baseline vs. delta time from baseline for the HIFF fitness function for bitstring chromosomes in C++ and zig.">>=
zig.hiff.string <- read.csv("../data/sea25-hiff-11-Jan-12-03-44.csv")
zig.hiff.string$delta.PSys <- zig.hiff.string$PSys - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
zig.hiff.string$delta.seconds <- zig.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.hiff.string$language <- "zig"
cpp.hiff.string <- read.csv("../data/sea-string-hiff-11-Jan-13-39-12.csv")
names(cpp.hiff.string)[names(cpp.hiff.string) == "Psys"] <- "PSys"
names(cpp.hiff.string)[names(cpp.hiff.string) == "Core"] <- "Cores"
cpp.hiff.string$delta.PSys <- cpp.hiff.string$PSys - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PSys)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PSys)`,30))
cpp.hiff.string$delta.seconds <- cpp.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.hiff.string$language <- "c++"

hiff.data <- rbind(zig.hiff.string, cpp.hiff.string)
hiff.data$size <- factor(hiff.data$size)
ggplot(hiff.data, aes(x=delta.seconds, y=delta.PSys, color=language, shape=size)) + geom_point() + theme_minimal() + labs(x="Delta time from baseline (s)", y="Delta energy from baseline (J)")
@

Despite being pervasive and used extensively, and thus amenable to energy benchmarking, genetic operators and simple fitness functions do not spend a significant amount of energy, and any saving obtained by any choice of language, data structure of parametrization will be relatively small (although, cumulatively throughout all experiments, it will amount to a considerable amount of energy saved). We would need a more heavy-duty function in order to give a definitive answer to which language would spend less energy in an evolutionary algorithm context. This is why we also test the HIFF (hierarchical if and only if) function \cite{watson1998modeling}, used extensively in the evolutionary algorithm literature, which is a recursive integer arithmetic function that takes a Boolean string of 0s and 1s as input and returns an integer result.

From the point of view of benchmarking energy consumption its recursivity involve many heap allocations and handling of return values, as well as the pure integer operation of the most basic atomic function; this is why it is a good candidate for energy profiling. We have again worked only with bit strings (previously proved to be the most energy-efficient data structure) and tested for the three chromosome lengths used so far: 512, 1024 and 2048 bits. In this case, we have subtracted the baseline measurements used for chromosome creation since anyway energy consumed by this operation will be one or more orders of magnitude bigger than baseline. The result is plotted in Figure \ref{fig:energy.gecco.hiff}. The advantage of C++, in red in this case, is quite clear, with {\sf zig} taking twice as much time and consuming double the energy of C++ for the biggest size, although we can observe again the high dispersion of values, which in this case is higher for {\sf zig}, with many outliers and a high standard deviation. We do not think that this is a result of the experimental measurement, since the dispersion of C++ is much lower, and there does not seem to be a connection between the time every run needs and the standard deviation (which would be the case if unexpected system-level events would have caused that dispersion). This does not affect, however, the fact that C++ clearly consumes less energy for this problem.

<<energy.gecco.hiff.opsxjoule, echo=F, message=F>>=
hiff.data$ops.joule <- 40000/hiff.data$delta.PSys

hiff.data %>% group_by(language, size) %>% summarise(`mean(delta.PSys)`=mean(delta.PSys), `sd(delta.PSys)`=sd(delta.PSys), `mean(delta.seconds)`=mean(delta.seconds), `sd(delta.seconds)`=sd(delta.seconds), `mean(ops.joule)`=mean(ops.joule), `sd(ops.joule)`=sd(ops.joule)) -> hiff.data.summary

library(kableExtra)

hiff.data.summary$Joules <- paste0(round(hiff.data.summary$`mean(delta.PSys)`,2), " (", round(hiff.data.summary$`sd(delta.PSys)`,2), ")")
hiff.data.summary$"Ops per Joule" <- paste0(round(hiff.data.summary$`mean(ops.joule)`,2), " (", round(hiff.data.summary$`sd(ops.joule)`,2), ")")

hiff.data.summary %>% select(language, size, Joules, "Ops per Joule") %>% arrange(size) %>% kable(digits=2, caption="\\protect\\label{tab:opsxjoule}Comparison of c++ and zig, HIFF function") %>% kable_styling(full_width = F)
@

This is summarized in Table~\ref{tab:opsxjoule}, where we show the standard measurement for energy profiling, and operations performed per Joule spent. Across the board, the number of HIFF calls that C++ is able to perform is 3x (or more) those {\sf zig} makes for the same amount of Joules, and this is for a function that really needs a good amount of energy, so choosing one over the other would result in a considerably greener evolutionary algorithm implementation.

This last experiment proves that, in general, C++ is likely to be a better choice than {\sf zig}, resulting in energy savings that can be considerable and up to 60\% in some cases. This would answer research question 3, with measurements indicating that C++ can achieve on average at least 2x operations per Joule with respect to  {\sf zig} for the same problem.

\section{Conclusions}\label{sec:conclusions}

In this paper we have tried to use a methodology that eliminates part of the overhead by using a baseline measurement; however, in the case of functions under study being relatively lightweight, it is very difficult to obtain values that go beyond baseline; in this, the effect of optimizations made by the compiler may be an important factor, compounded by the lack of precision of the estimations of energy consumption in the RAPL registers. In general, the researcher should try to set up the experiments so that functions under study consume a substantial multiple of the baseline.

The experiments reveal that, for this specific kind of problem where only integer arithmetic and language-specific functions are used, C++ emerges as the clear winner, with, in some cases, half the consumption of the other contestant, {\sf zig}. Should we totally discard {\sf zig} for evolutionary algorithms? Certainly in the short term; however, it is a language with certain peculiarities, and it might need a different approach to algorithm implementations; it might be interesting to keep an eye on {\sf zig} in the mid and certainly long term.

After the experiments show that the standard deviation in {\sf zig} is much higher than in C++, working on the worst case scenario might be a good idea, because a good average energy consumption might be marred by outliers where there is a very high consumption (something that has been observed, for instance, in Java Virtual Machine based languages like Kotlin). Adding more statistical measurements for comparison could mitigate this issue but also trying to find an experimental setup that would reduce or mitigate this variability for certain languages.

\begin{acks}
  Hidden for double-blind review
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{energy,GAs,ours,cplusplus}

\end{document}
