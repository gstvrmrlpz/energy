\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{gensymb}

\setcopyright{acmcopyright}

\acmDOI{xx.xxx/xxx_x}

\acmISBN{979-8-4007-0629-5/25/03}

%Conference
\acmConference[SAC'25]{ACM SAC Conference}{March 31 â€“April 4, 2025}{Sicily, Italy}
\acmYear{2025}
\copyrightyear{2025}


\acmArticle{4}
\acmPrice{15.00}

\begin{document}
\title{Energy consumption of evolutionary algorithms implemented in low-level languages}
\subtitle{Comparison of C++ and {\sf zig} in key evolutionary algorithm functions}

\renewcommand{\shorttitle}{TBD}

  \author{Juan-Juli\'an Merelo Guerv\'os}
  \orcid{0000-0002-1385-9741}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{jmerelo@ugr.es}

  \author{Gustavo Romero}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{gustavo@ugr.es}

  \author{Mario Garc\'ia Valdez}
  \orcid{0000-0002-2593-1114}
  \affiliation{%
    \institution{Tecnol\'ogico Nacional de M\'exico}
    \city{Tijuana}
    \country{M\'exico}
    \postcode{22414}
  }
  \email{mario@tectijuana.edu.mx}
% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{JJ Merelo et al.}

\begin{abstract}
Green software engineering is good software engineering, since trying to design systems in such a way that they consume a minimal amount of energy is simply an efficient way of consuming resources. Scientific software is no exception; in this case we will put our focus on evolutionary algorithms, and the patterns of energy consumption for two different, low-level, languages: The mature C++ and the emerging {\sf zig}. By setting up a methodology that gives us a precise measure of the energy spent by key evolutionary algorithm functions, we can give the scientific software engineer some actionable insights on how to write energy-conscious evolutionary algorithms. Our experiments show that, even having very low energy consumption in both cases, C++ using the well-known GNU compiler can can achieve a 50\% reduction in energy consumption for some integer-based fitness functions, as well as very good performance on classical genetic operators. Besides, the experimental results have a low variability, as compared to {\sf zig}, making it in the short and medium run the best of the two languages for evolutionary algorithms.

\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011074.10011075.10011079.10011080</concept_id>
       <concept_desc>Software and its engineering~Software design techniques</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797</concept_id>
       <concept_desc>Theory of computation~Optimization with randomized search heuristics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010061.10011795</concept_id>
       <concept_desc>Theory of computation~Random search heuristics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797.10011799</concept_id>
       <concept_desc>Theory of computation~Evolutionary algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010941.10010949.10010957.10010964</concept_id>
       <concept_desc>Software and its engineering~Power management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Software design techniques}
\ccsdesc[300]{Theory of computation~Optimization with randomized search heuristics}
\ccsdesc[500]{Theory of computation~Random search heuristics}
\ccsdesc[500]{Theory of computation~Evolutionary algorithms}
\ccsdesc[500]{Software and its engineering~Power management}

\keywords{Green computing, software engineering, evolutionary algorithms, genetic algorithms, energy-aware algorithms}


\maketitle

Creating efficient software should include efficiency in energy consumption, so that implementation of algorithms do not imply excessive depletion of resources. But computing, and eventually optimizing, the energy consumption of any algorithm needs measurements, since the complex interplay of algorithm, implementation, language and hardware makes it impossible to create fixed rules as there are for performance. For starters, we need to focus on a specific family of algorithms and address the key operators and functions used in them; we are interested in evolutionary algorithms and our focus will be on specific functions like (benchmark) fitness functions, as well as common genetic operators.

Thus, in this paper, we will compare different implementations of the essential functions in evolutionary algorithms in two languages, C++ and {\sf zig}, looking at answering the following research questions:\begin{itemize}
\item Is there a combination of data structure and language that is significantly better than the rest?
\item Of the two factors that determine energy consumption, time and power, can we determine if there is a dominant term that makes the specific combination found above faster?
\end{itemize}

We will work with two different languages: C++ and {\sf zig}; the first is mature and popular, the second has yet to enter the mainstream but can offer new solutions in this area. We will also focus on two different data structures: bit vectors and bit strings, that have a different storage model and in general different energy profiles.

As was established in other papers \cite{wivace23}, we have used {\sf pinpoint} \cite{pinpoint}, an open source tool, to measure the energy consumed by specific processes. This tool taps the RAPL API to collect the energy consumption by the "package" (PKG), that is, the CPU as well as the memory. Measurements are repeated 30 times, using
a Linux machine {\tt 5.15.0-119-generic \#129~20.04.1-Ubuntu SMP} with an AMD Ryzen 9 3950X 16-Core Processor, we use {\sf zig}  version 0.13.0, which is the last stable one at the time of writing this paper; {\tt g++} used is at version {\tt 10.5.0}.

We will perform the experiment in two stages: first we establish baseline measurements using the generation of chromosomes. This allows us to eliminate the background consumption, as well as all consumption that does not correspond precisely to the functions under study; if needed, this will allow us also to drop some combination of data structure and language that are especially inefficient. We will perform these baseline measurements for two different data structures, a character array (where every element is represented by a character 0 or 1) or a Boolean array (with every element represented by a value that is equal to {\sf True} or {\sf False}).

<<energy.sac.generation, echo=FALSE, message=FALSE, fig.height=3, fig.cap="Energy vs. time for the chromosome generation problem. Point size changes with chromosome size.">>=
library(knitr)
zig.gen.bool <- read.csv("../data/sac-gen-bool-25-Sep-19-46-01.csv")
zig.gen.bool$data.structure <- "bvector"
zig.gen.string <- read.csv("../data/sac-gen-string-25-Sep-19-44-59.csv")
zig.gen.string$data.structure <- "string"
cpp.gen.bool <- read.csv("../data/c++-bvector-gen.csv")
cpp.gen.bool$data.structure <- "bvector"
cpp.gen.string <- read.csv("../data/cpp-string-27-Sep-20-36-43.csv")
cpp.gen.string$data.structure <- "string"

gen.data <- rbind(zig.gen.bool, zig.gen.string, cpp.gen.bool, cpp.gen.string)
gen.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
gen.data$point.size <- log2(gen.data$size)-7

library(dplyr)
gen.data %>% group_by(language, data.structure, size ) %>% summarise(mean(PKG), sd(PKG), mean(seconds), sd(seconds)) -> gen.data.summary

library(ggplot2)
ggplot(gen.data, aes(x=seconds, y=PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + geom_smooth(method="lm", aes( group=interaction(language,data.structure))) + labs(x="Time (s)", y="Energy (J)")+guides(size="none")
gen.data$size <- as.factor(gen.data$size)
@

What we have represented in Figure~\ref{fig:energy.sac.generation} is an energy consumption ($y$ axis) vs time ($x$ axis) plot for every experiment in the two languages, using the two target data structures. We have plotted a linear regression for the slope, that would represent the power consumed (being power equal to energy divided by time). We can appreciate in this picture how the differences across languages and data structures are not so clear cut. C++ (red) seems better for the smallest size (512 bits), but it is definitely worse for the largest size.

<<energy.sac.ops, echo=FALSE, message=FALSE, fig.height=3, fig.cap="Boxplot of PKG energy consumption using the bit string chromosome for the two languages and different sizes",  fig.align="center">>=
zig.ops.bool <- read.csv("../data/sac-2025-zig-ops-bool.csv")
zig.ops.bool$data.structure <- "bvector"
zig.ops.bool$delta.PKG <- zig.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.bool$delta.seconds <- zig.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.ops.string <- read.csv("../data/sac-2025-zig-ops-string.csv")
zig.ops.string$data.structure <- "string"
zig.ops.string$delta.PKG <- zig.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.string$delta.seconds <- zig.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.bool <- read.csv("../data/cpp-bool-ops-30-Sep-09-03-07.csv")
cpp.ops.bool$data.structure <- "bvector"
cpp.ops.bool$delta.PKG <- cpp.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.bool$delta.seconds <- cpp.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.string <- read.csv("../data/cpp-string-ops-30-Sep-09-00-11.csv")
cpp.ops.string$data.structure <- "string"
cpp.ops.string$delta.PKG <- cpp.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.string$delta.seconds <- cpp.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))

ops.data <- rbind(zig.ops.bool, zig.ops.string, cpp.ops.bool, cpp.ops.string)
ops.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
ops.data$point.size <- log2(ops.data$size)-7

ops.data %>% group_by(language, data.structure, size) %>% summarise(mean(delta.PKG), sd(delta.PKG), mean(delta.seconds), sd(delta.seconds)) -> ops.data.summary

# ggplot(ops.data, aes(x=delta.seconds, y=delta.PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + labs(x="Time (s)", y="Energy (J)") + theme(legend.position="none")

ops.data$size <- as.factor(ops.data$size)
ggplot(ops.data[ops.data$data.structure=="string",], aes(x=size, y=PKG, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Chromosome size", y="Energy (J)")
string.ops.data <- ops.data[ops.data$data.structure=="string",]
differences.512 <- t.test(string.ops.data[string.ops.data$size==512 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==512 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.1024 <- t.test(string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.2048 <- t.test(string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="zig",]$PKG, alternative = "greater")
string.ops.data$power <- string.ops.data$PKG/string.ops.data$seconds
@

The second stage involves actual genetic operators. In order to measure energy consumed we generate 40K bitstrings and then performs genetic operators on them (mutation, crossover and application of the Count-ones (onemax) function. After initial experiments showed that Boolean vectors showed worse performance for any measurement, we will continue only with bit strings. The result for these is shown in Figure \ref{fig:energy.sac.ops}; side by side, energy spent by C++ (left of tick) and {\sf zig} (right) are shown. The picture is more nuanced than what we observed in Figure \ref{fig:energy.sac.generation}: C++ beats {\sf zig} for the lesser sizes and is beaten by {\sf zig} by a small margin for the larger size. Side-by-side differences are significant, so in this case there is a real difference between the two languages, although it is not always in the same direction. Initial experiments showed that in some cases, subtracting the baseline resulted in 0 or negative difference; this is why we have plotted the total energy consumed (which includes system overhead).

<<energy.sac.hiff, echo=FALSE, message=FALSE, fig.height=3, fig.cap="Delta energy from baseline vs. delta time from baseline for the HIFF fitness function for bitstring chromosomes.">>=
zig.hiff.string <- read.csv("../data/sac-hiff-string-1-Oct-17-33-52.csv")
zig.hiff.string$delta.PKG <- zig.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.hiff.string$delta.seconds <- zig.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.hiff.string$language <- "zig"
cpp.hiff.string <- read.csv("../data/cpp-string-hiff-1-Oct-17-39-37.csv")
cpp.hiff.string$delta.PKG <- cpp.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.hiff.string$delta.seconds <- cpp.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.hiff.string$language <- "c++"

hiff.data <- rbind(zig.hiff.string, cpp.hiff.string)
hiff.data$size <- factor(hiff.data$size)
ggplot(hiff.data, aes(x=delta.seconds, y=delta.PKG, color=language, shape=size)) + geom_point() + theme_minimal() + labs(x="Delta time from baseline (s)", y="Delta energy from baseline (J)")
@

We would be also interested on the energy consumption of heavy-duty fitness functions. We will use HIFF (Hierarchical If and Only If) \cite{watson1998modeling}, which is a recursive integer arithmetic function that takes a Boolean string of 0s and 1s as input and returns an integer; the process of recursion involves many function calls that will require the use of the stack and, sometimes, the heap. From the point of view of benchmarking energy consumption its recursivity involve many heap allocations and handling of return values, as well as the raw integer operation of the most basic atomic function; this is why it is a good candidate for energy profiling. We have again worked only with bit strings (previously proved to be the most energy-efficient data structure) and tested for the three chromosome lengths used so far: 512, 1024 and 2048 bits. In this case, we have subtracted the baseline measurements used for chromosome creation. The result is plotted in Figure \ref{fig:energy.sac.hiff}. The advantage of C++, in red in this case, is quite clear, with {\sf zig} taking twice as much time and consuming double the energy of C++ for the biggest size, although we can observe again the high dispersion of values, which is higher for {\sf zig}, with many outliers and a high standard deviation. We do not think that this is a result of the experimental measurement, since the dispersion of C++ is much lower, and there does not seem to be a connection between the time every run needs and the standard deviation (which would be the case if unexpected system-level events would have caused that dispersion). This does not affect, however, the fact that C++ clearly consumes less energy for this problem.

<<sac.hiff.opsxjoule, echo=F, message=F>>=
hiff.data$ops.joule <- 40000/hiff.data$delta.PKG

hiff.data %>% group_by(language, size) %>% summarise(`mean(delta.PKG)`=mean(delta.PKG), `sd(delta.PKG)`=sd(delta.PKG), `mean(delta.seconds)`=mean(delta.seconds), `sd(delta.seconds)`=sd(delta.seconds), `mean(ops.joule)`=mean(ops.joule), `sd(ops.joule)`=sd(ops.joule)) -> hiff.data.summary

library(kableExtra)

hiff.data.summary$Joules <- paste0(round(hiff.data.summary$`mean(delta.PKG)`,2), " (", round(hiff.data.summary$`sd(delta.PKG)`,2), ")")
hiff.data.summary$"Ops per Joule" <- paste0(round(hiff.data.summary$`mean(ops.joule)`,2), " (", round(hiff.data.summary$`sd(ops.joule)`,2), ")")

hiff.data.summary %>% select(language, size, Joules, "Ops per Joule") %>% arrange(size) %>% kable(digits=2, caption="\\protect\\label{tab:opsxjoule}Comparison of c++ and zig, HIFF function") %>% kable_styling(full_width = F)
@

This is summarized in Table~\ref{tab:opsxjoule}, where we show the standard measurement for energy profiling, and operations performed per Joule extracted. Across the board, the number of HIFF calls that C++ is able to perform is 2x (or more) those {\sf zig} makes for the same amount of Joules, and this is for a function that really needs a good amount of energy.

This last experiment proves that, for a wide range of optimization problems solved via evolutionary algorithms that is limited to integer-based functions, that is, most benchmark functions and many combinatorial optimization functions, C++ is likely to be a better choice than {\sf zig}, resulting in energy savings that can be considerable and up to 50\% in some cases\footnote{The fact that {\sf zig}, as an emerging language, has not gathered enough popularity to be even considered is not really relevant in this case. What this paper establishes is a checkpoint (for {\sf zig} in version 0.13) that will need to be revisited in the future, as the language evolves and reaches version 1.0. At any rate, the wide advantage that C++ enjoys will not likely be closed in the near future}.

\section{Conclusions}\label{sec:conclusions}

In this paper, we compared the energy spent by functions characteristic of evolutionary algorithms in two languages: C++ and {\sf zig}. We have used a proven methodology that tries to eliminate the overhead of the rest of the system in order to focus on the energy needed by the specific functions we are interested in, even in an experimental context with a high variability caused by external causes (using a system where no other processes are running is not really practical or feasible for the average scientist) as well as internal (energy management in modern computer systems is a complex process with many inputs that cannot be controlled by the user). We have tried to use a methodology that eliminates part of the overhead by using a baseline measurement; however, in the case of functions under study being relatively lightweight, it is very difficult to obtain values that go beyond baseline; in this, the effect of optimizations made by the compiler may be an important factor. In general, the researcher should try to set up the experiment so that functions under study consume a substantial multiple of the baseline. We will take that into account in future studies.

The experiments reveal that, for this specific kind of problem where only integer arithmetic and language-specific functions are used, C++ emerges as the clear winner, with 50\% the consumption of the other contestant, {\sf zig}. There is a single case where {\sf zig} is better, but there is a small difference, and it is not enough to totally discard C++ or even find a specific corner case where it would be worth the energy savings to create a whole algorithm in {\sf zig}.

Should we totally discard {\sf zig} for evolutionary algorithms? Indeed, it is a short-term decision we could feel comfortable with. However, it is a language with certain peculiarities, and it might need an approach to algorithm implementations that might be totally different from the one made in C++; we have tried to make the code as close as possible to each other, and we do not have the same amount of experience with {\sf zig} than we have with C++, so it might be interesting to keep an eye on {\sf zig} in the mid and certainly long term.

We should also bear in mind that these results were taken in an AMD system, where energy spent by the memory cannot be measured separately. Using a pure Intel system would help us find some of the causes of this difference; extending measurement to other operating systems might also give us some additional information. These are two possible lines of work to explore in the future, but other possible venues of research would be to work on other kind of real-valued functions, including the ones used in normal benchmarks such as BBOB, or extending measurements to full-fledged algorithms that run for a certain number of generations.

After the experiments show that the standard deviation in {\sf zig} is much higher than in C++, working on the worst case scenario might be a good idea, because a good average energy consumption might be marred by outliers where there is a very high consumption (something that has been observed, for instance, in Java Virtual Machine based languages like Kotlin). Adding more statistical measurements for comparison could mitigate this issue, but also trying to find an experimental setup that would reduce or mitigate this variability for certain languages. And now that we are mentioning other languages, JVM based languages like Java itself are very popular in the EA community, and a good candidate for comparison. Other popular languages, like Python, are high-level and in general those have a much higher per-operation energy consumption. A fair comparison using low-energy-consumption software engineering practices and patterns might, anyway, give us good insights on good software engineering applied to evolutionary algorithms.

\begin{acks}
This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR), as well as PID2023-147409NB-C22 and Plan Propio de InvestigaciÃ³n y Transferencia project PPJIA2023-031
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{energy,GAs,ours,cplusplus}

\end{document}
