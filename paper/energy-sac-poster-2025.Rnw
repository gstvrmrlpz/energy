\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{gensymb}

\copyrightyear{2025}
\acmYear{2025}
\setcopyright{rightsretained}
\acmConference[SAC '25]{The 40th ACM/SIGAPP Symposium on Applied Computing}{March 31-April 4, 2025}{Catania, Italy}
\acmBooktitle{The 40th ACM/SIGAPP Symposium on Applied Computing (SAC'25), March 31-April 4, 2025, Catania, Italy}
\acmDOI{10.1145/3672608.3707829}
\acmISBN{979-8-4007-0629-5/25/03}

\begin{document}
\title{Energy consumption of evolutionary algorithms implemented in low-level languages}
\subtitle{Comparison of C++ and {\sf zig} in key evolutionary algorithm functions}

\renewcommand{\shorttitle}{TBD}

  \author{Juan-Juli\'an Merelo Guerv\'os}
  \orcid{0000-0002-1385-9741}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{jmerelo@ugr.es}

  \author{Gustavo Romero}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{gustavo@ugr.es}

  \author{Mario Garc\'ia Valdez}
  \orcid{0000-0002-2593-1114}
  \affiliation{%
    \institution{Tecnol\'ogico Nacional de M\'exico}
    \city{Tijuana}
    \country{M\'exico}
    \postcode{22414}
  }
  \email{mario@tectijuana.edu.mx}
% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{JJ Merelo et al.}

\begin{abstract}
In this paper, we focus on how the main operations in evolutionary algorithms spend energy in two different languages: C++ and {\sf zig}. By setting up a methodology that gives us a precise measure of the energy spent by key evolutionary algorithm functions, we can give the scientific software engineer some actionable insights on how to write energy-conscious evolutionary algorithms. Our experiments show that C++ using the well-known GNU compiler can achieve a 50\% reduction in energy consumption for some integer-based fitness functions, as well as very good performance on classical genetic operators.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10010061.10011795</concept_id>
       <concept_desc>Theory of computation~Random search heuristics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797.10011799</concept_id>
       <concept_desc>Theory of computation~Evolutionary algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010941.10010949.10010957.10010964</concept_id>
       <concept_desc>Software and its engineering~Power management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Random search heuristics}
\ccsdesc[500]{Theory of computation~Evolutionary algorithms}
\ccsdesc[500]{Software and its engineering~Power management}

\keywords{Green computing, evolutionary algorithms}


\maketitle

Creating efficient software should include efficiency in energy consumption, so that the implementation of algorithms does not imply excessive depletion of resources. But computing, and eventually optimizing, the energy consumption of any algorithm needs measurements, since the complex interplay of the algorithm, implementation, language, and hardware make it impossible to create fixed rules as there are for performance. For starters, we need to focus on a specific family of algorithms and address the key operators and functions used in them; we are interested in evolutionary algorithms and our focus will be on specific functions like (benchmark) fitness functions, as well as common genetic operators.

Thus, in this paper, we will compare different implementations of the essential functions in evolutionary algorithms in two languages, C++ and {\sf zig}, looking at answering the following research questions:\begin{itemize}
\item Is there a combination of data structure and language that is significantly better than the rest?
\item Of the two factors that determine energy consumption, time and power, can we determine if there is a dominant term that makes the specific combination found above faster?
\end{itemize}

We will work with two different languages: C++ and {\sf zig}; the first is mature and popular, the second has yet to enter the mainstream but can offer new solutions in this area. We will also focus on two different data structures: bit vectors and bit strings, that have a different storage model and, in general, different energy profiles. As was established in other papers \cite{wivace23}, we have used {\sf pinpoint} \cite{pinpoint}, an open source tool, to measure the energy consumed by specific processes. This tool taps the RAPL API to collect the energy consumption by the "package" (PKG), that is, the CPU as well as the memory. Measurements are repeated 30 times.

We will perform the experiment in two stages: first, we establish baseline measurements using the generation of chromosomes. This allows us to eliminate the background consumption, as well as all consumption that does not correspond precisely to the functions under study; if needed, this will allow us also to drop some combination of data structure and language that are especially inefficient. We will perform these baseline measurements for two different data structures, a character array (where every element is represented by a character 0 or 1) or a Boolean array (with every element represented by a value that is equal to {\sf True} or {\sf False}).

<<energy.sac.generation, echo=FALSE, message=FALSE, fig.height=2.75, fig.cap="Energy vs. time for the chromosome generation problem. Point size changes with chromosome size.">>=
library(knitr)
zig.gen.bool <- read.csv("../data/sac-gen-bool-25-Sep-19-46-01.csv")
zig.gen.bool$data.structure <- "bvector"
zig.gen.string <- read.csv("../data/sac-gen-string-25-Sep-19-44-59.csv")
zig.gen.string$data.structure <- "string"
cpp.gen.bool <- read.csv("../data/c++-bvector-gen.csv")
cpp.gen.bool$data.structure <- "bvector"
cpp.gen.string <- read.csv("../data/cpp-string-27-Sep-20-36-43.csv")
cpp.gen.string$data.structure <- "string"

gen.data <- rbind(zig.gen.bool, zig.gen.string, cpp.gen.bool, cpp.gen.string)
gen.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
gen.data$point.size <- log2(gen.data$size)-7

library(dplyr)
gen.data %>% group_by(language, data.structure, size ) %>% summarise(mean(PKG), sd(PKG), mean(seconds), sd(seconds)) -> gen.data.summary

library(ggplot2)
ggplot(gen.data, aes(x=seconds, y=PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + geom_smooth(method="lm", aes( group=interaction(language,data.structure))) + labs(x="Time (s)", y="Energy (J)")+guides(size="none")
gen.data$size <- as.factor(gen.data$size)
@

What we have represented in Figure~\ref{fig:energy.sac.generation} is an energy consumption ($y$ axis) vs time ($x$ axis) plot for every experiment in the two languages, using the two target data structures. We have plotted a linear regression for the slope, that would represent the power consumed (being power equal to energy divided by time). We can appreciate in this picture how the differences across languages and data structures are not so clear-cut. C++ (red) seems better for the smallest size (512 bits), but definitely worse for the largest size.

<<energy.sac.ops, echo=FALSE, message=FALSE, fig.height=2.75, fig.cap="Boxplot of PKG energy consumption using the bit string chromosome for the two languages and different sizes",  fig.align="center">>=
zig.ops.bool <- read.csv("../data/sac-2025-zig-ops-bool.csv")
zig.ops.bool$data.structure <- "bvector"
zig.ops.bool$delta.PKG <- zig.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.bool$delta.seconds <- zig.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.ops.string <- read.csv("../data/sac-2025-zig-ops-string.csv")
zig.ops.string$data.structure <- "string"
zig.ops.string$delta.PKG <- zig.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.string$delta.seconds <- zig.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.bool <- read.csv("../data/cpp-bool-ops-30-Sep-09-03-07.csv")
cpp.ops.bool$data.structure <- "bvector"
cpp.ops.bool$delta.PKG <- cpp.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.bool$delta.seconds <- cpp.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.string <- read.csv("../data/cpp-string-ops-30-Sep-09-00-11.csv")
cpp.ops.string$data.structure <- "string"
cpp.ops.string$delta.PKG <- cpp.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.string$delta.seconds <- cpp.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))

ops.data <- rbind(zig.ops.bool, zig.ops.string, cpp.ops.bool, cpp.ops.string)
ops.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
ops.data$point.size <- log2(ops.data$size)-7

ops.data %>% group_by(language, data.structure, size) %>% summarise(mean(delta.PKG), sd(delta.PKG), mean(delta.seconds), sd(delta.seconds)) -> ops.data.summary

# ggplot(ops.data, aes(x=delta.seconds, y=delta.PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + labs(x="Time (s)", y="Energy (J)") + theme(legend.position="none")

ops.data$size <- as.factor(ops.data$size)
ggplot(ops.data[ops.data$data.structure=="string",], aes(x=size, y=PKG, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Chromosome size", y="Energy (J)")
string.ops.data <- ops.data[ops.data$data.structure=="string",]
differences.512 <- t.test(string.ops.data[string.ops.data$size==512 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==512 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.1024 <- t.test(string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.2048 <- t.test(string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="zig",]$PKG, alternative = "greater")
string.ops.data$power <- string.ops.data$PKG/string.ops.data$seconds
@

The second stage involves actual genetic operators. In order to measure the energy consumed, we generate 40K bitstrings and then perform genetic operators on them (mutation, crossover, and application of the Count-ones (onemax) function. After initial experiments showed that Boolean vectors showed worse performance for any measurement, we will continue only with bit strings. These results are shown in Figure \ref{fig:energy.sac.ops}; side by side, energy spent by C++ (left of tick) and {\sf zig} (right) are shown. The picture is more nuanced than what we observed in Figure \ref{fig:energy.sac.generation}: C++ beats {\sf zig} for the lesser sizes and is beaten by {\sf zig} by a small margin for the larger size. Side-by-side differences are significant, so in this case there is a real difference between the two languages, although it is not always in the same direction. Initial experiments showed that in some cases, subtracting the baseline resulted in 0 or negative difference; this is why we have plotted the total energy consumed (which includes system overhead).

<<energy.sac.hiff, echo=FALSE, message=FALSE, fig.height=2.75, fig.cap="Delta energy from baseline vs. delta time from baseline for the HIFF fitness function for bitstring chromosomes.">>=
zig.hiff.string <- read.csv("../data/sac-hiff-string-1-Oct-17-33-52.csv")
zig.hiff.string$delta.PKG <- zig.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.hiff.string$delta.seconds <- zig.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.hiff.string$language <- "zig"
cpp.hiff.string <- read.csv("../data/cpp-string-hiff-1-Oct-17-39-37.csv")
cpp.hiff.string$delta.PKG <- cpp.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.hiff.string$delta.seconds <- cpp.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.hiff.string$language <- "c++"

hiff.data <- rbind(zig.hiff.string, cpp.hiff.string)
hiff.data$size <- factor(hiff.data$size)
ggplot(hiff.data, aes(x=delta.seconds, y=delta.PKG, color=language, shape=size)) + geom_point() + theme_minimal() + labs(x="Delta time from baseline (s)", y="Delta energy from baseline (J)")
@

We would also be interested on the energy consumption of heavy-duty fitness functions. We will use HIFF (Hierarchical If and Only If) \cite{watson1998modeling}, which is a recursive integer arithmetic function that takes a Boolean string of 0s and 1s as input and returns an integer; the process of recursion involves many function calls that will require the use of the stack and, sometimes, the heap. From the point of view of benchmarking energy consumption, its recursivity involves many heap allocations and handling of return values, as well as the raw integer operation of the most basic atomic function; this is why it is a good candidate for energy profiling. We have again worked only with bit strings (previously proved to be the most energy-efficient data structure) and tested for the three chromosome lengths used so far: 512, 1024, and 2048 bits. In this case, we have subtracted the baseline measurements used for chromosome creation. The result is plotted in Figure \ref{fig:energy.sac.hiff}. The advantage of C++, in red in this case, is quite clear, with {\sf zig} taking twice as much time and consuming double the energy of C++ for the biggest size, although we can observe again the high dispersion of values, which is higher for {\sf zig}, with many outliers and a high standard deviation. We do not think that this is a result of the experimental measurement, since the dispersion of C++ is much lower, and there does not seem to be a connection between the time every run needs and the standard deviation (which would be the case if unexpected system-level events would have caused that dispersion). This does not affect, however, the fact that C++ clearly consumes less energy for this problem.

<<sac.hiff.opsxjoule, echo=F, message=F>>=
hiff.data$ops.joule <- 40000/hiff.data$delta.PKG

hiff.data %>% group_by(language, size) %>% summarise(`mean(delta.PKG)`=mean(delta.PKG), `sd(delta.PKG)`=sd(delta.PKG), `mean(delta.seconds)`=mean(delta.seconds), `sd(delta.seconds)`=sd(delta.seconds), `mean(ops.joule)`=mean(ops.joule), `sd(ops.joule)`=sd(ops.joule)) -> hiff.data.summary

library(kableExtra)

hiff.data.summary$Joules <- paste0(round(hiff.data.summary$`mean(delta.PKG)`,2), " (", round(hiff.data.summary$`sd(delta.PKG)`,2), ")")
hiff.data.summary$"Ops per Joule" <- paste0(round(hiff.data.summary$`mean(ops.joule)`,2), " (", round(hiff.data.summary$`sd(ops.joule)`,2), ")")

hiff.data.summary %>% select(language, size, Joules, "Ops per Joule") %>% arrange(size) %>% kable(digits=2, caption="\\protect\\label{tab:opsxjoule}Comparison of c++ and zig, HIFF function") %>% kable_styling(full_width = F)
@

This is summarized in Table~\ref{tab:opsxjoule}, where we show the standard energy profiling measurement, and operations performed per Joule extracted. Across the board, the number of HIFF calls that C++ is able to perform is 2x (or more) than those {\sf zig} makes for the same amount of Joules, and this is for a function that really needs a good amount of energy. This proves that C++ is likely to be a better choice than {\sf zig}, resulting in energy savings that can be considerable and up to 50\% in some cases, allowing researchers to reduce their carbon footprint.

\begin{acks}
This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project PID2023-147409NB-C22 and Plan Propio de Investigación y Transferencia project PPJIA2023-031
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{energy,GAs,ours,cplusplus}

\end{document}
