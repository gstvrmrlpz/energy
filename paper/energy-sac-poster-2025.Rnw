\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{gensymb}

\setcopyright{acmcopyright}

\acmDOI{xx.xxx/xxx_x}

\acmISBN{979-8-4007-0629-5/25/03}

%Conference
\acmConference[SAC'25]{ACM SAC Conference}{March 31 –April 4, 2025}{Sicily, Italy}
\acmYear{2025}
\copyrightyear{2025}


\acmArticle{4}
\acmPrice{15.00}

\begin{document}
\title{Energy consumption of evolutionary algorithms implemented in low-level languages}
\subtitle{Comparison of C++ and {\sf zig} in key evolutionary algorithm functions}

\renewcommand{\shorttitle}{TBD}

  \author{Juan-Juli\'an Merelo Guerv\'os}
  \orcid{0000-0002-1385-9741}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{jmerelo@ugr.es}

  \author{Gustavo Romero}
  \affiliation{%
    \institution{Universidad de Granada/CITIC}
    \city{Granada}
    \country{Spain}
    \postcode{18071}
  }
  \email{gustavo@ugr.es}

  \author{Mario Garc\'ia Valdez}
  \orcid{0000-0002-2593-1114}
  \affiliation{%
    \institution{Tecnol\'ogico Nacional de M\'exico}
    \city{Tijuana}
    \country{M\'exico}
    \postcode{22414}
  }
  \email{mario@tectijuana.edu.mx}
% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{JJ Merelo et al.}

\begin{abstract}
Green software engineering is good software engineering, since trying to design systems in such a way that they consume a minimal amount of energy is simply an efficient way of consuming resources. Scientific software is no exception; in this case we will put our focus on evolutionary algorithms, and the patterns of energy consumption for two different, low-level, languages: The mature C++ and the emerging {\sf zig}. By setting up a methodology that gives us a precise measure of the energy spent by key evolutionary algorithm functions, we can give the scientific software engineer some actionable insights on how to write energy-conscious evolutionary algorithms. Our experiments show that, even having very low energy consumption in both cases, C++ using the well-known GNU compiler can can achieve a 50\% reduction in energy consumption for some integer-based fitness functions, as well as very good performance on classical genetic operators. Besides, the experimental results have a low variability, as compared to {\sf zig}, making it in the short and medium run the best of the two languages for evolutionary algorithms.

\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011074.10011075.10011079.10011080</concept_id>
       <concept_desc>Software and its engineering~Software design techniques</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797</concept_id>
       <concept_desc>Theory of computation~Optimization with randomized search heuristics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010061.10011795</concept_id>
       <concept_desc>Theory of computation~Random search heuristics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797.10011799</concept_id>
       <concept_desc>Theory of computation~Evolutionary algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010941.10010949.10010957.10010964</concept_id>
       <concept_desc>Software and its engineering~Power management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Software design techniques}
\ccsdesc[300]{Theory of computation~Optimization with randomized search heuristics}
\ccsdesc[500]{Theory of computation~Random search heuristics}
\ccsdesc[500]{Theory of computation~Evolutionary algorithms}
\ccsdesc[500]{Software and its engineering~Power management}

\keywords{Green computing, software engineering, evolutionary algorithms, genetic algorithms, energy-aware algorithms}


\maketitle

Creating efficient software should include efficiency in energy consumption, so that implementation of algorithms do not imply excessive depletion of resources. But computing, and eventually optimizing, the energy consumption of any algorithm needs measurements, since the complex interplay of algorithm, implementation, language and hardware makes it impossible to create fixed rules as there are for performance. For starters, we need to focus on a specific family of algorithms and address the key operators and functions used in them; we are interested in evolutionary algorithms and our focus will be on specific functions like (benchmark) fitness functions, as well as common genetic operators.

Thus, in this paper, we will compare different implementations of the essential functions in evolutionary algorithms in two languages, C++ and {\sf zig}, looking at answering the following research questions:\begin{itemize}
\item Is there a combination of data structure and language that is significantly better than the rest?
\item Of the two factors that determine energy consumption, time and power, can we determine if there is a dominant term that makes the specific combination found above faster?
\end{itemize}

As was established in other papers \cite{wivace23}, we have used {\sf pinpoint} \cite{pinpoint}, an open source tool, to measure the energy consumed by specific processes. This tool taps the RAPL API to collect the energy consumption by the "package" (PKG), that is, the CPU as well as the memory. Measurements are repeated 30 times, using
a Linux machine {\tt 5.15.0-119-generic \#129~20.04.1-Ubuntu SMP} with an AMD Ryzen 9 3950X 16-Core Processor, we use {\sf zig}  version 0.13.0, which is the last stable one at the time of writing this paper; {\tt g++} used is at version {\tt 10.5.0}.

We take measurements in two stages: first we establish baseline measurements using the generation of chromosomes. This allows us to eliminate the background consumption, as well as all consumption that does not correspond precisely to the functions under study; if needed, this will allow us also to drop some combination of data structure and language that are especially inefficient. We will perform these baseline measurements for two different data structures, a character array (where every element is represented by a character 0 or 1) or a Boolean array (with every element represented by a value that is equal to {\sf True} or {\sf False}).

<<energy.sac.generation, echo=FALSE, message=FALSE, fig.height=3, fig.cap="Energy vs. time for the chromosome generation problem. Point size changes with chromosome size.">>=
library(knitr)
zig.gen.bool <- read.csv("../data/sac-gen-bool-25-Sep-19-46-01.csv")
zig.gen.bool$data.structure <- "bvector"
zig.gen.string <- read.csv("../data/sac-gen-string-25-Sep-19-44-59.csv")
zig.gen.string$data.structure <- "string"
cpp.gen.bool <- read.csv("../data/c++-bvector-gen.csv")
cpp.gen.bool$data.structure <- "bvector"
cpp.gen.string <- read.csv("../data/cpp-string-27-Sep-20-36-43.csv")
cpp.gen.string$data.structure <- "string"

gen.data <- rbind(zig.gen.bool, zig.gen.string, cpp.gen.bool, cpp.gen.string)
gen.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
gen.data$point.size <- log2(gen.data$size)-7

library(dplyr)
gen.data %>% group_by(language, data.structure, size ) %>% summarise(mean(PKG), sd(PKG), mean(seconds), sd(seconds)) -> gen.data.summary

library(ggplot2)
ggplot(gen.data, aes(x=seconds, y=PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + geom_smooth(method="lm", aes( group=interaction(language,data.structure))) + labs(x="Time (s)", y="Energy (J)")+guides(size="none")
@

What we have represented in Figure~\ref{fig:energy.sac.generation} is an energy consumption ($y$ axis) vs time ($x$ axis) plot for every experiment in the two languages, using the two target data structures. We have plotted a linear regression for the slope, that would represent the power consumed (being power equal to energy divided by time). We can appreciate in this picture how the differences across languages and data structures are not so clear cut. C++ (red) seems better for the smallest size (512 bits), but it is definitely worse for the largest size. Differences are small and nuanced enough to proceed without discarding any language or data structure before analyzing the results obtained for the genetic operators, which we will do next.

<<energy.sac.generation.boxplot, echo=FALSE, message=FALSE, fig.cap="Energy boxplot for the chromosome generation problem (baseline).">>=
gen.data$size <- as.factor(gen.data$size)
ggplot(gen.data, aes(x=size, y=PKG, fill=language,linetype=data.structure)) + geom_boxplot() + theme_minimal() + labs(x="Data structure", y="Energy (J)")
@

Figure~\ref{fig:energy.sac.generation.boxplot} synthesizes in a single chart the energy consumption for the chromosome generation problem for both languages and data structures. It grows much faster for C++ than for {\sf zig}. While it is slightly better for the smallest size, energy consumption for strings is virtually the same for the middle size, but it takes off for the largest size. However, it is curious to observe, that a specific data structure does not guarantee better energy consumption: Boolean vectors consume more energy in C++, while they consume {\em less} in {\sf zig}.

<<energy.sac.histo, echo=F, message=F, fig.cap="Histogram of energy consumption for the generation of Boolean vectors in C++ of length 2048",  fig.align="center">>=
ggplot(cpp.gen.bool[ cpp.gen.bool$size == 2048,], aes(x=PKG)) + geom_histogram(binwidth = 2) + theme_minimal() + labs(x="Energy (J)", y="Frequency")
@

It is interesting to note in this Figure~\ref{fig:energy.sac.ops}, however, the dispersion of the data points along the $y$ axis (Energy). While other factors in the hardware and operating system may cause some spread over the $x$ axis (time), variation is relatively small; however, energy spent even for running times that are very similar might experience variations on the order of 10 joules (for this specific problem), which is around 20\% of the total energy measured. In Figure \ref{fig:energy.sac.histo} we plot the histogram of energy consumption for the option with the most extensive range, Boolean vectors in C++ of length 2048. Besides seeing a skewed distribution, the range of variation goes from 50 to 90 for the 30 experiments. This, on one hand, indicates the presence of a system overhead that is difficult to eliminate, but also is a symptom of the complicated relationship between hardware and software managed by the different energy handling mechanisms in the operating system, firmware, and CPU microcode. This makes energy consumption relatively unpredictable (within a certain range of variation). In this set of experiments, we have increased the number to 30 (as opposed to 15), trying to follow a more rigorous statistical approach.


We need, however, to measure the consumption of actual genetic operators. We will do this in the next section.

\section{Results}\label{sec:results}

<<energy.sac.ops, echo=FALSE, message=FALSE, fig.cap="Delta energy from baseline vs. delta time from baseline for genetic operators problem. Shapes and colors as in the previous Figure.">>=
zig.ops.bool <- read.csv("../data/sac-2025-zig-ops-bool.csv")
zig.ops.bool$data.structure <- "bvector"
zig.ops.bool$delta.PKG <- zig.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.bool$delta.seconds <- zig.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.ops.string <- read.csv("../data/sac-2025-zig-ops-string.csv")
zig.ops.string$data.structure <- "string"
zig.ops.string$delta.PKG <- zig.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.ops.string$delta.seconds <- zig.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.bool <- read.csv("../data/cpp-bool-ops-30-Sep-09-03-07.csv")
cpp.ops.bool$data.structure <- "bvector"
cpp.ops.bool$delta.PKG <- cpp.ops.bool$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.bool$delta.seconds <- cpp.ops.bool$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="bvector" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.ops.string <- read.csv("../data/cpp-string-ops-30-Sep-09-00-11.csv")
cpp.ops.string$data.structure <- "string"
cpp.ops.string$delta.PKG <- cpp.ops.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.ops.string$delta.seconds <- cpp.ops.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))

ops.data <- rbind(zig.ops.bool, zig.ops.string, cpp.ops.bool, cpp.ops.string)
ops.data$language <- c(rep("zig", nrow(zig.gen.bool)), rep("zig", nrow(zig.gen.string)), rep("c++", nrow(cpp.gen.bool)), rep("c++", nrow(cpp.gen.string)))
ops.data$point.size <- log2(ops.data$size)-7

ops.data %>% group_by(language, data.structure, size) %>% summarise(mean(delta.PKG), sd(delta.PKG), mean(delta.seconds), sd(delta.seconds)) -> ops.data.summary

ggplot(ops.data, aes(x=delta.seconds, y=delta.PKG, color=language)) + geom_point(aes(fill=data.structure,shape=data.structure,size=point.size)) + theme_minimal() + labs(x="Time (s)", y="Energy (J)") + theme(legend.position="none")
@

We have performed a series of experiments using a triad of genetic operators: crossover, mutation and count-ones, following this algorithm
\begin{algorithm}
\caption{Appliation of genetic operators}
\label{alg:ops}
\begin{algorithmic}
\FOR{$i=1$ to $N$ by 2}
\STATE $c1 \leftarrow$ chromosome[i]
\STATE $c2 \leftarrow$ chromosome[i+1]
\STATE mutate($c1$)
\STATE mutate($c2$)
\STATE ($new\_c1, new\_c2$) $\leftarrow$ crossover($c1$, $c2$)
\STATE fitnessArray.append(count\_ones($new\_c1$)
\STATE fitnessArray.append(count\_ones($new\_c2$)
\STATE chromosomeArray.append($new\_c1$)
\STATE chromosomeArray.append($new\_c2$)
\ENDFOR
\STATE Show size of chromosomeArray
\end{algorithmic}
\end{algorithm}

The results of applying these operators to the chromosome have been shown in Figure~\ref{fig:energy.sac.ops}, where the average energy consumption and time for every size, language, and data structure have been subtracted from the numeric value obtained. However, we observe  that applying the genetic operators {\em after} its generation results in less-than-0 energy consumption and, in some cases, negative time. Nevertheless, what we see also is a clear separation between circles (corresponding to Boolean vectors) and triangles (corresponding to strings); the former {\em do} have some energy consumption and can then be discarded as more energy-consuming, at least in the context of this experiment. However, we do observe that the (negative) energy consumption is larger for C++ than for Zig, so even if it means combining two operations (generation and genetic operators) that are usually performed in disparate number of calls, we will compare the actual wallclock time. For the time being, we will not discuss the interpretation of this negative time/consumption, however, we will leave that to the last Section.


<<energy.sac.string, echo=F, message=F, fig.cap="Boxplot of PKG energy consumption using the bit string chromosome for the two languages and different sizes",  fig.align="center">>=
ops.data$size <- as.factor(ops.data$size)
ggplot(ops.data[ops.data$data.structure=="string",], aes(x=size, y=PKG, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Time (s)", y="Energy (J)")
string.ops.data <- ops.data[ops.data$data.structure=="string",]
differences.512 <- t.test(string.ops.data[string.ops.data$size==512 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==512 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.1024 <- t.test(string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==1024 & string.ops.data$language=="zig",]$PKG,alternative = "less")
differences.2048 <- t.test(string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="c++",]$PKG, string.ops.data[string.ops.data$size==2048 & string.ops.data$language=="zig",]$PKG, alternative = "greater")
@

We have plotted the total energy consumed for the program that generates 40K bitstrings and then performs genetic operators on them in Figure \ref{fig:energy.sac.string}; side by side, energy spent by C++ (left of tick) and {\sf zig} (right) are shown. The picture is more nuanced than what we observed in Figure \ref{fig:energy.sac.generation.boxplot}: C++ beats {\sf zig} for the lesser sizes and is beaten by {\sf zig} by a small margin for the larger size. Side-by-side differences are significant, so in this case there is a real difference between the two languages, although it is not always in the same direction.

<<energy.sac.string.power, echo=F, message=F, fig.cap="Boxplot of PKG power consumption using the bit string chromosome for the two languages and different sizes",  fig.align="center">>=
string.ops.data$power <- string.ops.data$PKG/string.ops.data$seconds
ggplot(string.ops.data, aes(x=size, y=power, color=language)) + geom_boxplot(notch=T) + geom_point(aes(fill=language,shape=language)) + theme_minimal() + labs(x="Time (s)", y="Power (w)")
@

In order to ascertain what is the key to the low energy consumption in the case of C++, we also plot the power consumption in Figure \ref{fig:energy.sac.string.power}, by dividing energy by time. The result shows that while C++ draws an apparently constant amount of power from the package (processor and memory), the amount used by {\sf zig} increases with the amount of memory needed for the different computations. This is an interesting result, which is probably related to the different way C++ and {\sf zig} handle memory allocation. At any rate, it shows less power consumption in the case of C++, which makes us conclude that  {\sf zig} achieves better energy consumption by taking less to perform in a specific workload, possibly using more memory to do so. This might be the case for more general workloads, but it needs to be confirmed, due to the small number of these studies that have been published so far.

<<energy.sac.hiff, echo=FALSE, message=FALSE, fig.cap="Delta energy from baseline vs. delta time from baseline for the HIFF fitness function for bitstring chromosomes in C++ and zig.">>=
zig.hiff.string <- read.csv("../data/sac-hiff-string-1-Oct-17-33-52.csv")
zig.hiff.string$delta.PKG <- zig.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
zig.hiff.string$delta.seconds <- zig.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="zig" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
zig.hiff.string$language <- "zig"
cpp.hiff.string <- read.csv("../data/cpp-string-hiff-1-Oct-17-39-37.csv")
cpp.hiff.string$delta.PKG <- cpp.hiff.string$PKG - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(PKG)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(PKG)`,30))
cpp.hiff.string$delta.seconds <- cpp.hiff.string$seconds - c(rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==512,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==1024,]$`mean(seconds)`,30), rep(gen.data.summary[gen.data.summary$language=="c++" & gen.data.summary$data.structure=="string" & gen.data.summary$size==2048,]$`mean(seconds)`,30))
cpp.hiff.string$language <- "c++"

hiff.data <- rbind(zig.hiff.string, cpp.hiff.string)
hiff.data$size <- factor(hiff.data$size)
ggplot(hiff.data, aes(x=delta.seconds, y=delta.PKG, color=language, shape=size)) + geom_point() + theme_minimal() + labs(x="Delta time from baseline (s)", y="Delta energy from baseline (J)")
@

Despite being pervasive and used extensively, and thus amenable to energy benchmarking, genetic operators and simple fitness functions do not spend a significant amount of energy, and any saving obtained will be relatively small (although, cumulatively throughout all experiments, it will amount to a considerable amount of energy saved). We would need a more heavy-duty function in order to give a definitive answer to which language would spend less energy in an evolutionary algorithm context. This is why we also test the HIFF (hierarchical if and only if) function \cite{watson1998modeling}, used extensively in evolutionary algorithm literature, which is a recursive integer arithmetic function that takes a Boolean string of 0s and 1s as input and returns an integer result. The function works by recursively splitting the input string into halves and applying itself to each half. The result depends on the arrangement of 0s and 1s in the original string, and the process of recursion involves many function calls that will require the use of the stack and, sometimes, the heap.

From the point of view of evolutionary algorithms, it is a function that introduces a very rough fitness landscape, so it works to test the efficiency of different genetic operators \cite{khor2008problem,fernandes2014shuffle}, but from the point of view of benchmarking energy consumption its recursivity involve many heap allocations and handling of return values, as well as the pure integer operation of the most basic atomic function; this is why it is a good candidate for energy profiling. We have again worked only with bit strings (previously proved to be the most energy-efficient data structure) and tested for the three chromosome lengths used so far: 512, 1024 and 2048 bits. In this case, we have subtracted the baseline measurements used for chromosome creation. The result is plotted in Figure \ref{fig:energy.sac.hiff}. The advantage of C++, in red in this case, is quite clear, with {\sf zig} taking twice as much time and consuming double the energy of C++ for the biggest size, although we can observe again the high dispersion of values, which is higher for {\sf zig}, with many outliers and a high standard deviation. We do not think that this is a result of the experimental measurement, since the dispersion of C++ is much lower, and there does not seem to be a connection between the time every run needs and the standard deviation (which would be the case if unexpected system-level events would have caused that dispersion). This does not affect, however, the fact that C++ clearly consumes less energy for this problem.

<<sac.hiff.opsxjoule, echo=F, message=F>>=
hiff.data$ops.joule <- 40000/hiff.data$delta.PKG

hiff.data %>% group_by(language, size) %>% summarise(`mean(delta.PKG)`=mean(delta.PKG), `sd(delta.PKG)`=sd(delta.PKG), `mean(delta.seconds)`=mean(delta.seconds), `sd(delta.seconds)`=sd(delta.seconds), `mean(ops.joule)`=mean(ops.joule), `sd(ops.joule)`=sd(ops.joule)) -> hiff.data.summary

library(kableExtra)

hiff.data.summary$Joules <- paste0(round(hiff.data.summary$`mean(delta.PKG)`,2), " (", round(hiff.data.summary$`sd(delta.PKG)`,2), ")")
hiff.data.summary$"Ops per Joule" <- paste0(round(hiff.data.summary$`mean(ops.joule)`,2), " (", round(hiff.data.summary$`sd(ops.joule)`,2), ")")

hiff.data.summary %>% select(language, size, Joules, "Ops per Joule") %>% arrange(size) %>% kable(digits=2, caption="\\protect\\label{tab:opsxjoule}Comparison of c++ and zig, HIFF function") %>% kable_styling(full_width = F)
@

This is summarized in Table~\ref{tab:opsxjoule}, where we show the standard measurement for energy profiling, and operations performed per Joule extracted. Across the board, the number of HIFF calls that C++ is able to perform is 2x (or more) those {\sf zig} makes for the same amount of Joules, and this is for a function that really needs a good amount of energy.

This last experiment proves that, for a wide range of optimization problems solved via evolutionary algorithms that is limited to integer-based functions, that is, most benchmark functions and many combinatorial optimization functions, C++ is likely to be a better choice than {\sf zig}, resulting in energy savings that can be considerable and up to 50\% in some cases\footnote{The fact that {\sf zig}, as an emerging language, has not gathered enough popularity to be even considered is not really relevant in this case. What this paper establishes is a checkpoint (for {\sf zig} in version 0.13) that will need to be revisited in the future, as the language evolves and reaches version 1.0. At any rate, the wide advantage that C++ enjoys will not likely be closed in the near future}.

\section{Conclusions}\label{sec:conclusions}

In this paper, we compared the energy spent by functions characteristic of evolutionary algorithms in two languages: C++ and {\sf zig}. We have used a proven methodology that tries to eliminate the overhead of the rest of the system in order to focus on the energy needed by the specific functions we are interested in, even in an experimental context with a high variability caused by external causes (using a system where no other processes are running is not really practical or feasible for the average scientist) as well as internal (energy management in modern computer systems is a complex process with many inputs that cannot be controlled by the user). We have tried to use a methodology that eliminates part of the overhead by using a baseline measurement; however, in the case of functions under study being relatively lightweight, it is very difficult to obtain values that go beyond baseline; in this, the effect of optimizations made by the compiler may be an important factor. In general, the researcher should try to set up the experiment so that functions under study consume a substantial multiple of the baseline. We will take that into account in future studies.

The experiments reveal that, for this specific kind of problem where only integer arithmetic and language-specific functions are used, C++ emerges as the clear winner, with 50\% the consumption of the other contestant, {\sf zig}. There is a single case where {\sf zig} is better, but there is a small difference, and it is not enough to totally discard C++ or even find a specific corner case where it would be worth the energy savings to create a whole algorithm in {\sf zig}.

Should we totally discard {\sf zig} for evolutionary algorithms? Indeed, it is a short-term decision we could feel comfortable with. However, it is a language with certain peculiarities, and it might need an approach to algorithm implementations that might be totally different from the one made in C++; we have tried to make the code as close as possible to each other, and we do not have the same amount of experience with {\sf zig} than we have with C++, so it might be interesting to keep an eye on {\sf zig} in the mid and certainly long term.

We should also bear in mind that these results were taken in an AMD system, where energy spent by the memory cannot be measured separately. Using a pure Intel system would help us find some of the causes of this difference; extending measurement to other operating systems might also give us some additional information. These are two possible lines of work to explore in the future, but other possible venues of research would be to work on other kind of real-valued functions, including the ones used in normal benchmarks such as BBOB, or extending measurements to full-fledged algorithms that run for a certain number of generations.

After the experiments show that the standard deviation in {\sf zig} is much higher than in C++, working on the worst case scenario might be a good idea, because a good average energy consumption might be marred by outliers where there is a very high consumption (something that has been observed, for instance, in Java Virtual Machine based languages like Kotlin). Adding more statistical measurements for comparison could mitigate this issue, but also trying to find an experimental setup that would reduce or mitigate this variability for certain languages. And now that we are mentioning other languages, JVM based languages like Java itself are very popular in the EA community, and a good candidate for comparison. Other popular languages, like Python, are high-level and in general those have a much higher per-operation energy consumption. A fair comparison using low-energy-consumption software engineering practices and patterns might, anyway, give us good insights on good software engineering applied to evolutionary algorithms.

\begin{acks}
This work is supported by the Ministerio espa\~{n}ol de Econom\'{\i}a y
Competitividad (Spanish Ministry of Competitivity and Economy) under project
PID2020-115570GB-C22 (DemocratAI::UGR), as well as PID2023-147409NB-C22 and Plan Propio de Investigación y Transferencia project PPJIA2023-031
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{energy,GAs,ours,cplusplus}

\end{document}
