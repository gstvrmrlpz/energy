\documentclass[sigconf]{acmart}

\setcopyright{acmcopyright}

\acmDOI{xx.xxx/xxx_x}

\acmISBN{979-8-4007-0629-5/25/03}

%Conference
\acmConference[SAC'25]{ACM SAC Conference}{March 31 â€“April 4, 2025}{Sicily, Italy}
\acmYear{2025}
\copyrightyear{2025}

\acmArticle{4}
\acmPrice{15.00}

\begin{document}

\title{Energy consumption of C++ standard random number generators}
\subtitle{}

\renewcommand{\shorttitle}{Energy consumption of C++ standard random number generators}

\author{Ben Trovato}
\authornote{Boilerplate author names have been kept for double-blind review.}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \country{USA}
  \postcode{43017-6221}
}
\email{trovato@corporation.com}

\renewcommand{\shortauthors}{B. Trovato}

\begin{abstract}
Random number generation is a widely used yet poorly understood topic among its users. In this paper, we aim to explore one of its lesser-known aspects: energy consumption. Most studies on the subject tend to focus on the quality of the generators or on measuring their execution times. However, energy consumption is a critical concern today, particularly for mobile devices. In this work, we have measured the energy consumption of standard C++ random number generators. The results reveal differences in energy usage of over a thousand-fold, which could be significant for applications that require the generation of large quantities of random numbers, such as learning algorithms and metaheuristics.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10011007.10011074.10011075.10011079.10011080</concept_id>
       <concept_desc>Software and its engineering~Software design techniques</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797</concept_id>
       <concept_desc>Theory of computation~Optimization with randomized search heuristics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010061.10011795</concept_id>
       <concept_desc>Theory of computation~Random search heuristics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003809.10003716.10011136.10011797.10011799</concept_id>
       <concept_desc>Theory of computation~Evolutionary algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010941.10010949.10010957.10010964</concept_id>
       <concept_desc>Software and its engineering~Power management</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[300]{Software and its engineering~Software design techniques}
\ccsdesc[300]{Theory of computation~Optimization with randomized search heuristics}
\ccsdesc[500]{Theory of computation~Random search heuristics}
\ccsdesc[500]{Theory of computation~Evolutionary algorithms}
\ccsdesc[500]{Software and its engineering~Power management}

\keywords{Green computing, software engineering, evolutionary algorithms, genetic algorithms, energy-aware algorithms, random number generators}

\maketitle

\section{Introduction}
\label{sec:introduction}

Pseudo-random number generators \cite{marsaglia2003random} are a fundamental resource in computing, which is why they have been extensively studied in numerous works. However, most of these studies focus on the quality of the generated numbers or the efficiency of the algorithms that produce them. In this paper, we aim to focus on a less-studied aspect: the energy consumption of RNGs. This aspect is critical today, especially in mobile devices, where energy consumption is a limiting factor. In this work, we have measured the energy consumption of standard C++ RNGs.

Most of them are initialized with a series of numbers used as seeds. A one-way function is then applied to these seeds, resulting in a random number. To generate a new random number, the previous one is used as the new seed and is subjected to the same process.

The properties of RNGs can vary significantly depending on the field in which they are used. For certain applications, such as cryptography, generators must pass highly rigorous quality tests, such as Diehard \cite{marsaglia1997diehard} or TestU01 \cite{testu01}. However, for many other applications, such as genetic algorithms, the generators must be fast and efficient, even at the expense of lower quality. In fact, some studies suggest that genetic algorithms are not highly sensitive to the quality of RNGs \cite{cardenas2011sensitiveness}.

\section{Methodology}
\label{sec:methodology}

To measure the energy consumption of C++ RNGs, we wrote a program that generates 100 million random numbers using each of the C++ standard engines:
\begin{itemize}
    \item \texttt{std::knuth\_b}
    \item \texttt{std::minstd\_rand0} (\texttt{std::default\_random\_generator})
    \item \texttt{std::minstd\_rand}
    \item \texttt{std::mt19937} \cite{mersennetwister}.
    \item \texttt{std::mt19937\_64} \cite{mersennetwister}.
    \item \texttt{std::ranlux24\_base}
    \item \texttt{std::ranlux48\_base}
    \item \texttt{std::ranlux24} \cite{JAMES1994111}.
    \item \texttt{std::ranlux48} \cite{JAMES1994111}.
\end{itemize}

We also included other well-known generators, either due to their relevance (\texttt{rand} de C), their inclusion in trendy programming languages like Rust and Zig, or their role in the state of the art:

\begin{itemize}
    \item \texttt{rand} de C.
    \item \texttt{mt11213b} \cite{mersennetwister}.
    \item \texttt{romutrio32} y \texttt{romutrio} \cite{overton2020romufastnonlinearpseudorandom}.
    \item \texttt{xoroshiro128+} \cite{blackman2021scrambled}.
    \item \texttt{xoshiro256+} \cite{blackman2021scrambled}.
\end{itemize}

To measure energy consumption, we used perf \cite{perf}, which allows for this through the Running Average Power Limit (RAPL) standard \cite{rapl}. Each program was executed 100 times to obtain reasonable statistical accuracy on a Fedora Linux system with an AMD Ryzen3 3100 processor.

Since perf can only measure the energy consumption of the entire system as a whole, we implemented a specific methodology to isolate the energy consumption of a single process. Our approach involved two steps:

\begin{enumerate}
\item We measured the energy consumption of our program during its execution.
\item We then measured the energy consumption of the sleep command for a duration equal to our program's execution time.
\end{enumerate}

The difference between these two measurements provides an estimate of the isolated energy consumption of our program. This method allows us to differentiate between the baseline system energy consumption and the additional energy consumed by our specific process.

\section{Results}
\label{sec:results}

As can be seen from the results in Figure \ref{fig:pkg}, the energy consumption of the different generators varies significantly. The CPU time spent by the generators is also shown in Figure \ref{fig:cpu}. There is a clear correlation between energy consumption and CPU time, with the most efficient generators in terms of energy consumption also being the fastest.

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{pkg.png}
\caption{Energy consumption of C++ standard RNGs.}
\label{fig:pkg}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\columnwidth]{cpu.png}
\caption{CPU time spent by C++ standard RNGs.}
\label{fig:cpu}
\end{figure}

% \begin{figure}
% \centering
% \includegraphics[width=\columnwidth]{all.png}
% \caption{Energy consumption of C++ standard RNGs.}
% \label{fig:all}
% \end{figure}

In our case, the 32 bits version of \texttt{romutrio}, \texttt{romutrio32}, is the most efficient in terms of energy consumption and CPU time, while the \texttt{ranlux48} generator is the least efficient. The differences between the generators are also reflected in Table \ref{tab:pkg}, which shows the means and standard deviations of the energy consumed and the CPU time spent by 100 runs of each engine creating 100 million random numbers. \texttt{romutrio32} consume the 0.09\% of the energy consumed by \texttt{ranlux48} and the 0.41\% of the CPU time spent by \texttt{ranlux48}.

\begin{table}
\centering
\caption{Means and standard deviations of energy consumption and CPU time of 100 runs of C++ standard engines when generating 100 million random numbers.}
\begin{tabular}{lcc}
\toprule
Generator & Energy (J) & Time (s) \\
\midrule
knuth\_b & 5.1256$\pm$1.4059 & 0.9778$\pm$0.0004 \\
minstd\_rand0 & 1.3238$\pm$0.7541 & 0.3985$\pm$\textbf{0.0002} \\
minstd\_rand & 1.3379$\pm$0.8194 & 0.3985$\pm$\textbf{0.0002} \\
mt19937 & 0.4116$\pm$0.0693 & 0.1891$\pm$0.0007 \\
mt19937\_64 & 0.4770$\pm$0.0759 & 0.1806$\pm$0.0019 \\
mt11213b & 0.3068$\pm$0.0482 & 0.1349$\pm$0.0006 \\
rand & 7.6998$\pm$1.1038 & 1.1750$\pm$0.0075 \\
ranlux24\_base & 3.0864$\pm$1.1094 & 0.5636$\pm$0.0013 \\
ranlux48\_base & 2.5486$\pm$0.9063 & 0.5145$\pm$0.0009 \\
ranlux24 & 39.5458$\pm$3.1765 & 5.3631$\pm$0.0193 \\
ranlux48 & 153.1331$\pm$6.6647 & 20.2619$\pm$0.0232 \\
romutrio32 & \textbf{0.1357}$\pm$0.0340 & \textbf{0.0826}$\pm$0.0004 \\
romutrio & 0.1415$\pm$0.0405 & 0.0848$\pm$0.0005 \\
xoroshiro128+ & 0.2037$\pm$\textbf{0.0313} & 0.1021$\pm$0.0005 \\
xoshiro256+ & 0.1817$\pm$0.0379 & 0.0968$\pm$\textbf{0.0002} \\
\bottomrule
\end{tabular}
\label{tab:pkg}
\end{table}

After \texttt{romutrio32} and \texttt{romutrio}, the next best engines are the Mersenne Twister \texttt{mt11213b} and XOR based ones from Marsaglia, \texttt{xoroshiro128+}, and \texttt{xoshiro256+}, though not by a large margin.

Is also important to note that most of the implementations with lower energy consumption are 32 bits based, although their corresponding 64 bits versions are not much worse. As we can see when comparing a couple of examples:
\begin{itemize}
\item \texttt{mt19937\_64}, the 64 bits version of \texttt{mt19937}, consumes 15.89\% more energy and -4.49\% less CPU time.
\item \texttt{romutrio}, the 64 bits version of \texttt{romutrio32}, consumes 4.27\% more energy and 2.66\% less CPU time.
\end{itemize}

The energy consumption of the classic C \texttt{rand} generator is also very high, which is consistent with its poor performance in terms of CPU time. In spite of being one of the 32 bits implementations.

As a curious case, we can highlight \texttt{mt11213b}, one of the Mersenne Twister family generators. Its characteristics are among the best, and the only thing that differentiates it from \texttt{mt19937} is the set of constants and initial seeds. However, \texttt{mt11213b} consumes 34.16\% less energy and 40.18\% less CPU time than \texttt{mt19937}.

After \texttt{romutrio32} and \texttt{romutrio}, the next best engines are the Mersenne Twister \texttt{mt11213b} and the XOR-based ones from Marsaglia, \texttt{xoroshiro128+} and \texttt{xoshiro256+}, though the differences are not significant.

It is also important to note that most of the implementations with lower energy consumption are 32-bit based, although their corresponding 64-bit versions are not much worse. This can be observed in the following comparisons:

\begin{itemize}
    \item \texttt{mt19937\_64}, the 64-bit version of \texttt{mt19937}, consumes 15.89\% more energy and uses 4.49\% less CPU time.
    \item \texttt{romutrio}, the 64-bit version of \texttt{romutrio32}, consumes 4.27\% more energy and uses 2.66\% less CPU time.
\end{itemize}

The energy consumption of the classic C \texttt{rand} generator is also very high, which is consistent with its poor performance in terms of CPU time, despite being one of the 32-bit implementations.

A notable case is \texttt{mt11213b}, one of the Mersenne Twister family generators. Its characteristics are among the best, and the only difference between it and \texttt{mt19937} is the set of constants and initial seeds. However, \texttt{mt11213b} consumes 25.46\% less energy and 28.66\% less CPU time than \texttt{mt19937}.


\section{Conclusions}
\label{sec:conclusions}

This study highlights significant disparities in energy consumption among various C++ standard RNGs, revealing a difference of over three orders of magnitude between the most efficient generator, \texttt{romutrio32}, and the least efficient, \texttt{ranlux48}, with the latter consuming exactly 1,130.96 times more energy. This disparity has substantial implications for applications that require the generation of large volumes of random numbers, such as artificial intelligence, genetic algorithms, and other computational tasks with heavy random number usage.

In conclusion, the significant variation in energy consumption among C++ standard RNGs not only emphasizes the importance of careful selection in algorithm design but also points to the need for a broader awareness of energy implications in software development practices. This research contributes to the growing discourse on green computing, encouraging ongoing efforts to develop energy-efficient algorithms and systems.

\begin{acks}
Hidden for double-blind review
\end{acks}

\bibliographystyle{ACM-Reference-Format}
\bibliography{std-sac-poster-2025}

\end{document}
